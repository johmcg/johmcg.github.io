<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberSec Terminal Blog</title>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Marked.js for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        /* Custom CSS for terminal look and feel */
        body {
            background-color: #1a202c; /* Dark charcoal */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top */
            min-height: 100vh;
            padding: 2rem 1rem; /* Add padding for mobile */
            font-family: 'Fira Code', monospace;
            color: #e2e8f0; /* Light gray for general text */
            overflow-y: auto; /* Allow scrolling for long content */
        }

        .terminal-window {
            background-color: #0d1117; /* Even darker for terminal body */
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.25);
            width: 100%;
            max-width: 900px; /* Max width for desktop */
            min-height: 80vh; /* Minimum 80% of viewport height */
            height: auto; /* Allow height to adjust based on content if it exceeds min-height */
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid #2d3748; /* Darker border */
        }

        .terminal-header {
            background-color: #2d3748; /* Gray-blue header */
            padding: 0.5rem 1rem;
            border-top-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: #a0aec0; /* Lighter gray for header text */
            font-size: 0.875rem;
            border-bottom: 1px solid #1a202c;
        }

        .terminal-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .terminal-button {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #e53e3e; /* Red */
            border: 1px solid #c53030;
        }
        .terminal-button.yellow { background-color: #ecc94b; border-color: #d69e2e; }
        .terminal-button.green { background-color: #48bb78; border-color: #38a169; }

        .terminal-title {
            flex-grow: 1;
            text-align: center;
            font-weight: bold;
        }

        .terminal-body {
            flex-grow: 1;
            padding: 1.5rem;
            overflow-y: auto; /* Scrollable content area */
            line-height: 1.6;
            font-size: 0.95rem;
            color: #e2e8f0;
            white-space: pre-wrap; /* Preserve whitespace and wrap lines */
            word-break: break-word; /* Break long words */
        }

        .terminal-prompt {
            color: #48bb78; /* Green for prompt */
            margin-right: 0.5rem;
        }

        .terminal-input {
            color: #e2e8f0; /* Light gray for input */
        }

        .cursor {
            display: inline-block;
            width: 8px;
            height: 1em;
            background-color: #e2e8f0;
            vertical-align: middle;
            animation: blink 1s step-end infinite;
        }

        @keyframes blink {
            from, to { background-color: transparent; }
            50% { background-color: #e2e8f0; }
        }

        /* Styling for blog post elements within the terminal */
        .terminal-body h1, .terminal-body h2, .terminal-body h3, .terminal-body h4, .terminal-body h5, .terminal-body h6 {
            color: #63b3ed; /* Blue for titles */
            font-weight: bold;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
        }
        .terminal-body h1 { font-size: 1.5rem; }
        .terminal-body h2 { font-size: 1.3rem; }
        .terminal-body h3 { font-size: 1.1rem; color: #f6ad55; } /* Orange for section titles */

        .terminal-body p {
            margin-bottom: 1rem;
        }

        .terminal-body ul, .terminal-body ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
            list-style-type: disc; /* Default list style */
        }
        .terminal-body ol {
            list-style-type: decimal;
        }
        .terminal-body li {
            margin-bottom: 0.5rem;
        }

        .terminal-body pre {
            background-color: #1a202c; /* Darker background for code */
            padding: 0.75rem 1rem;
            border-radius: 0.375rem;
            margin-top: 0.75rem;
            margin-bottom: 0.75rem;
            overflow-x: auto; /* Allow horizontal scrolling for code */
            color: #cbd5e0; /* Lighter text for code */
            font-size: 0.85rem;
        }

        .terminal-body code {
            font-family: 'Fira Code', monospace;
            background-color: #2d3748; /* Slightly lighter for inline code */
            padding: 0.1rem 0.3rem;
            border-radius: 0.2rem;
        }

        .terminal-body a {
            color: #9f7aea; /* Purple for links */
            text-decoration: underline;
            cursor: pointer;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .terminal-window {
                min-height: 70vh; /* Adjust min-height for smaller screens */
            }
            .terminal-body {
                padding: 1rem;
                font-size: 0.875rem;
            }
            .terminal-header {
                padding: 0.4rem 0.8rem;
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <div class="terminal-window">
        <div class="terminal-header">
            <div class="terminal-buttons">
                <div class="terminal-button"></div>
                <div class="terminal-button yellow"></div>
                <div class="terminal-button green"></div>
            </div>
            <div class="terminal-title">user@cyberblog: ~</div>
            <div></div> <!-- Placeholder for right alignment -->
        </div>
        <div class="terminal-body" id="terminal-output">
            <!-- Content will be typed here by JavaScript -->
            <span class="terminal-prompt">user@cyberblog:~$</span> Loading posts...<span class="cursor"></span>
        </div>
        <div class="terminal-header">
            <span class="terminal-prompt">user@cyberblog:~$</span><span class="terminal-input"></span><span class="cursor"></span>
        </div>
    </div>

    <script>
        const terminalOutput = document.getElementById('terminal-output');
        const terminalInput = document.querySelector('.terminal-input');
        const cursor = document.querySelector('.cursor');

        // Configure marked.js
        marked.setOptions({
            gfm: true, // Use GitHub Flavored Markdown
            breaks: true, // Add <br> on a single newline
            highlight: function(code, lang) {
                // Basic highlighting. For full syntax highlighting, you would include a library like highlight.js
                // Example: <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
                // if (lang && hljs.getLanguage(lang)) { try { return hljs.highlight(code, { language: lang }).value; } catch (__) {} }
                return code;
            }
        });

        let postsMetadata = []; // This will hold the metadata loaded from posts.json
        let currentPostIndex = 0;
        let charIndex = 0;
        let typingSpeed = 20; // milliseconds per character

        function typeCharacter(targetElement, text, callback) {
            if (charIndex < text.length) {
                targetElement.innerHTML += text.charAt(charIndex);
                charIndex++;
                setTimeout(() => typeCharacter(targetElement, text, callback), typingSpeed);
            } else {
                if (callback) callback();
            }
        }

        function typeContent(contentHtml, callback) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = contentHtml;
            const nodes = Array.from(tempDiv.childNodes);

            let nodeIndex = 0;

            function typeNextNode() {
                if (nodeIndex < nodes.length) {
                    const node = nodes[nodeIndex];
                    const targetSpan = document.createElement('span');
                    terminalOutput.appendChild(targetSpan);

                    if (node.nodeType === Node.TEXT_NODE) {
                        charIndex = 0;
                        typeCharacter(targetSpan, node.textContent, () => {
                            nodeIndex++;
                            typeNextNode();
                        });
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        targetSpan.outerHTML = node.outerHTML;
                        const typedElement = terminalOutput.lastElementChild;
                        typedElement.innerHTML = '';

                        charIndex = 0;
                        typeCharacter(typedElement, node.innerHTML, () => {
                            nodeIndex++;
                            typeNextNode();
                        });
                    } else {
                        nodeIndex++;
                        typeNextNode();
                    }
                } else {
                    if (callback) callback();
                }
            }
            typeNextNode();
        }

        async function loadPost(postMetadata) {
            terminalOutput.innerHTML = ''; // Clear previous content
            terminalInput.textContent = ''; // Clear input area
            cursor.style.display = 'inline-block'; // Ensure cursor is visible for typing command

            const promptLine = document.createElement('span');
            promptLine.className = 'terminal-prompt';
            promptLine.textContent = 'user@cyberblog:~$ ';
            terminalOutput.appendChild(promptLine);

            charIndex = 0;
            const commandToType = `cat posts/${postMetadata.filename}`;
            typeCharacter(terminalInput, commandToType, async () => {
                terminalInput.textContent = commandToType; // Ensure full command is visible
                cursor.style.display = 'none'; // Hide cursor after command is "entered"

                setTimeout(async () => {
                    terminalOutput.innerHTML = ''; // Clear command line
                    terminalOutput.appendChild(document.createElement('br')); // New line after "enter"

                    try {
                        // Fetch the Markdown content
                        const response = await fetch(`posts/${postMetadata.filename}`);
                        if (!response.ok) {
                            throw new Error(`Failed to load post: ${response.statusText}`);
                        }
                        const markdownContent = await response.text();

                        // Type out the actual blog post title and date
                        const titleElement = document.createElement('span');
                        titleElement.className = 'post-title';
                        terminalOutput.appendChild(titleElement);
                        charIndex = 0;
                        typeCharacter(titleElement, postMetadata.title, () => {
                            const dateElement = document.createElement('span');
                            dateElement.className = 'post-date';
                            terminalOutput.appendChild(dateElement);
                            charIndex = 0;
                            typeCharacter(dateElement, `Date: ${postMetadata.date}`, () => {
                                terminalOutput.appendChild(document.createElement('br'));

                                // Convert Markdown to HTML and then type out the main content
                                const htmlContent = marked.parse(markdownContent);
                                typeContent(htmlContent, () => {
                                    terminalOutput.appendChild(document.createElement('br'));
                                    terminalOutput.appendChild(document.createElement('br'));
                                    const finalPrompt = document.createElement('span');
                                    finalPrompt.className = 'terminal-prompt';
                                    finalPrompt.textContent = 'user@cyberblog:~$ ';
                                    terminalOutput.appendChild(finalPrompt);
                                    cursor.style.display = 'inline-block';
                                    terminalInput.textContent = '';
                                    terminalOutput.scrollTop = terminalOutput.scrollHeight;
                                });
                            });
                        });
                    } catch (error) {
                        terminalOutput.innerHTML += `<br><span style="color: #e53e3e;">Error: Could not load post "${postMetadata.title}". ${error.message}</span><br>`;
                        terminalOutput.appendChild(document.createElement('br'));
                        const finalPrompt = document.createElement('span');
                        finalPrompt.className = 'terminal-prompt';
                        finalPrompt.textContent = 'user@cyberblog:~$ ';
                        terminalOutput.appendChild(finalPrompt);
                        cursor.style.display = 'inline-block';
                        terminalInput.textContent = '';
                        terminalOutput.scrollTop = terminalOutput.scrollHeight;
                    }
                }, 500);
            });
        }

        // Function to load the posts metadata
        async function loadPostsMetadata() {
            try {
                const response = await fetch('posts.json');
                if (!response.ok) {
                    throw new Error(`Failed to load posts.json: ${response.statusText}`);
                }
                postsMetadata = await response.json();
                if (postsMetadata.length > 0) {
                    loadPost(postsMetadata[currentPostIndex]);
                } else {
                    terminalOutput.innerHTML = '<span class="terminal-prompt">user@cyberblog:~$</span> echo "No blog posts found in posts.json."<br><span class="terminal-prompt">user@cyberblog:~$</span> <span class="cursor"></span>';
                }
            } catch (error) {
                terminalOutput.innerHTML = `<span style="color: #e53e3e;">Error: Could not load blog posts. Please ensure 'posts.json' exists and is correctly formatted. ${error.message}</span><br><span class="terminal-prompt">user@cyberblog:~$</span> <span class="cursor"></span>`;
                console.error("Error loading posts metadata:", error);
            }
        }

        // Load posts metadata when the page loads
        window.onload = loadPostsMetadata;

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const command = terminalInput.textContent.trim().toLowerCase();
                if (command === 'next' && currentPostIndex < postsMetadata.length - 1) {
                    currentPostIndex++;
                    loadPost(postsMetadata[currentPostIndex]);
                } else if (command === 'prev' && currentPostIndex > 0) {
                    currentPostIndex--;
                    loadPost(postsMetadata[currentPostIndex]);
                } else if (command === 'clear') {
                    terminalOutput.innerHTML = '';
                    terminalInput.textContent = '';
                    cursor.style.display = 'inline-block';
                } else if (command === 'ls') {
                    terminalOutput.innerHTML = '';
                    terminalInput.textContent = '';
                    cursor.style.display = 'none';
                    let output = '<span class="post-section-title">Available Posts:</span><br>';
                    postsMetadata.forEach((post, index) => {
                        // Use post.id for the cat command, and post.title for display
                        output += `<span class="terminal-prompt">${index + 1}.</span> <span class="post-link" onclick="loadPost(postsMetadata[${index}])">${post.title}</span><br>`;
                    });
                    terminalOutput.innerHTML = output;
                    setTimeout(() => {
                        terminalOutput.appendChild(document.createElement('br'));
                        const finalPrompt = document.createElement('span');
                        finalPrompt.className = 'terminal-prompt';
                        finalPrompt.textContent = 'user@cyberblog:~$ ';
                        terminalOutput.appendChild(finalPrompt);
                        cursor.style.display = 'inline-block';
                        terminalOutput.scrollTop = terminalOutput.scrollHeight;
                    }, 500);
                } else if (command.startsWith('cat ')) {
                    const searchTerm = command.substring(4).toLowerCase();
                    // Find post by filename (without .md) or by title fragment
                    const foundPost = postsMetadata.find(p =>
                        p.filename.toLowerCase().replace('.md', '').includes(searchTerm) ||
                        p.title.toLowerCase().includes(searchTerm)
                    );
                    if (foundPost) {
                        currentPostIndex = postsMetadata.indexOf(foundPost);
                        loadPost(foundPost);
                    } else {
                        terminalOutput.innerHTML += `<br><span style="color: #e53e3e;">Error: Post matching '${searchTerm}' not found.</span><br>`;
                        terminalOutput.appendChild(document.createElement('br'));
                        const finalPrompt = document.createElement('span');
                        finalPrompt.className = 'terminal-prompt';
                        finalPrompt.textContent = 'user@cyberblog:~$ ';
                        terminalOutput.appendChild(finalPrompt);
                        cursor.style.display = 'inline-block';
                        terminalInput.textContent = '';
                        terminalOutput.scrollTop = terminalOutput.scrollHeight;
                    }
                }
                else {
                    terminalOutput.innerHTML += `<br><span style="color: #e53e3e;">Error: Command '${command}' not found. Try 'ls', 'next', 'prev', 'cat [post_name]', or 'clear'.</span><br>`;
                    terminalOutput.appendChild(document.createElement('br'));
                    const finalPrompt = document.createElement('span');
                    finalPrompt.className = 'terminal-prompt';
                    finalPrompt.textContent = 'user@cyberblog:~$ ';
                    terminalOutput.appendChild(finalPrompt);
                    cursor.style.display = 'inline-block';
                    terminalInput.textContent = '';
                    terminalOutput.scrollTop = terminalOutput.scrollHeight;
                }
                terminalInput.textContent = '';
                e.preventDefault();
            } else if (e.key === 'Backspace') {
                terminalInput.textContent = terminalInput.textContent.slice(0, -1);
                e.preventDefault();
            } else if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
                terminalInput.textContent += e.key;
            }
        });

    </script>
</body>
</html>
